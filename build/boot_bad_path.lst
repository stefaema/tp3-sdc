     1                                  ; boot_ss_rw_ds_ro_test.asm - Stack R/W, Datos RO para prueba
     2                                  
     3                                  [bits 16]
     4                                  [org 0x7c00]
     5                                  
     6                                  ; --- Inicialización Modo Real ---
     7                                  start:
     8 00000000 B80000                      mov ax, 0
     9 00000003 8ED8                        mov ds, ax
    10 00000005 8EC0                        mov es, ax
    11 00000007 8ED0                        mov ss, ax
    12 00000009 BC007C                      mov sp, 0x7c00
    13                                  
    14 0000000C B80300                      mov ax, 0x0003
    15 0000000F CD10                        int 0x10
    16                                  
    17 00000011 BE[DD00]                    mov si, msg_starting
    18 00000014 E82100                      call print16_bios
    19                                  
    20                                      ; --- Transición a Modo Protegido ---
    21 00000017 BE[0A01]                    mov si, msg_gdt_load
    22 0000001A E81B00                      call print16_bios
    23                                  
    24 0000001D FA                          cli
    25 0000001E 0F0116[D700]                lgdt [gdt_descriptor]
    26                                  
    27 00000023 BE[1B01]                    mov si, msg_entering_pm
    28 00000026 E80F00                      call print16_bios
    29                                  
    30 00000029 0F20C0                      mov eax, cr0
    31 0000002C 6683C801                    or eax, 0x1
    32 00000030 0F22C0                      mov cr0, eax
    33                                  
    34 00000033 EA[4400]0800                jmp CODE_SEG:start_protected
    35                                  
    36                                  ; --- Rutina de Impresión Modo Real (BIOS) ---
    37                                  print16_bios:
    38 00000038 B40E                        mov ah, 0x0E
    39                                  .loop:
    40 0000003A AC                          lodsb
    41 0000003B 3C00                        cmp al, 0
    42 0000003D 7404                        je .done
    43 0000003F CD10                        int 0x10
    44 00000041 EBF7                        jmp .loop
    45                                  .done:
    46 00000043 C3                          ret
    47                                  
    48                                  ; =========================================================================
    49                                  [bits 32]
    50                                  ; =========================================================================
    51                                  
    52                                  start_protected:
    53                                      ; --- Configuración Modo Protegido ---
    54                                      ; PASO 1: Cargar DS, ES, FS, GS con el selector del segmento RO
    55 00000044 66B81800                    mov ax, DATA_RO_SEG    ; Usar selector RO (0x18) para datos generales
    56 00000048 8ED8                        mov ds, ax
    57 0000004A 8EC0                        mov es, ax
    58 0000004C 8EE0                        mov fs, ax
    59 0000004E 8EE8                        mov gs, ax
    60                                      ; SS se cargará con LSS usando el segmento R/W
    61                                  
    62                                      ; PASO 2: Configurar Stack ATÓMICAMENTE usando LSS y el segmento R/W
    63                                      ; stack_ptr necesita ser leído. ¿Puede DS (RO) leerlo? Sí.
    64                                      ; SS se cargará con DATA_RW_SEG (0x10).
    65 00000050 0FB225[CA010000]            lss esp, [stack_ptr]  ; Carga SS=0x10 y ESP=0x90000
    66                                  
    67                                      ; --- Código Principal Modo Protegido ---
    68 00000057 BAE0810B00                  mov edx, VID_MEM_BASE + (2 * 80 * 3) ; Fila 3
    69 0000005C BB[38010000]                mov ebx, msg_pm_active
    70 00000061 E83A000000                  call print32
    71                                  
    72 00000066 BA80820B00                  mov edx, VID_MEM_BASE + (2 * 80 * 4) ; Fila 4
    73 0000006B BB[4F010000]                mov ebx, msg_seg_stack_set_mix ; Mensaje adaptado
    74 00000070 E82B000000                  call print32
    75                                  
    76                                      ; --- Intento de Escritura en Segmento Read-Only (vía DS) ---
    77 00000075 BA20830B00                  mov edx, VID_MEM_BASE + (2 * 80 * 5) ; Fila 5
    78 0000007A BB[7C010000]                mov ebx, msg_attempt_write_ds
    79 0000007F E81C000000                  call print32
    80                                  
    81                                      ; PASO 3: ¡Intento de escritura usando DS (que es RO)!
    82 00000084 90                          nop
    83 00000085 66C70500000100ADDE          mov word [0x10000], 0xDEAD ; Intenta escribir en [DS(RO):0x10000]
    84                                                                 ; ¡Debería causar #GP!
    85                                  
    86                                      ; --- Código que NO debería ejecutarse ---
    87 0000008E BA60840B00                  mov edx, VID_MEM_BASE + (2 * 80 * 7) ; Fila 7
    88 00000093 BB[A4010000]                mov ebx, msg_write_succeeded_error
    89 00000098 E803000000                  call print32
    90                                  
    91                                  halt_loop:
    92 0000009D F4                          hlt
    93 0000009E EBFD                        jmp halt_loop
    94                                  
    95                                  ; --- Rutina de Impresión Modo Protegido (Memoria Video) ---
    96                                  VID_MEM_BASE equ 0xb8000
    97                                  print32:
    98 000000A0 60                          pusha
    99                                  .loop:
   100 000000A1 8A03                        mov al, [ebx]       ; Lee usando DS (ahora RO, pero leer está permitido)
   101 000000A3 B40F                        mov ah, 0x0F
   102 000000A5 3C00                        cmp al, 0
   103 000000A7 740C                        je .done
   104 000000A9 26668902                    mov [es:edx], ax    ; Escribe usando ES (también RO, pero escribir a memoria
   105                                                          ; de video a veces funciona o tiene efectos diferentes a RAM normal -
   106                                                          ; para ser más estrictos, print32 debería usar SS si queremos
   107                                                          ; estar seguros de escribir con un segmento R/W, pero dejémoslo así por ahora)
   108 000000AD 83C301                      add ebx, 1
   109 000000B0 83C202                      add edx, 2
   110 000000B3 EBEC                        jmp .loop
   111                                  .done:
   112 000000B5 61                          popa
   113 000000B6 C3                          ret
   114                                  
   115                                  ; =========================================================================
   116                                  ; Datos y GDT
   117                                  ; =========================================================================
   118                                  
   119                                  gdt_start:
   120                                  gdt_null: ; Índice 0
   121 000000B7 00000000                    dd 0x0
   122 000000BB 00000000                    dd 0x0
   123                                  gdt_code: ; Índice 1, Selector 0x08
   124 000000BF FFFF                        dw 0xFFFF; Limite(15:0)
   125 000000C1 0000                        dw 0x0000; Base(15:0)
   126 000000C3 00                          db 0x00;   Base(23:16)
   127 000000C4 9A                          db 0x9A;   Acceso (P=1,DPL=0,S=1,Type=1010 E/R)
   128 000000C5 CF                          db 0xCF;   Gran (G=1,D/B=1,L=0,AVL=0), Limite(19:16)
   129 000000C6 00                          db 0x00;   Base(31:24)
   130                                  gdt_data_rw: ; Índice 2, Selector 0x10 - *** READ/WRITE (PARA STACK SS) ***
   131 000000C7 FFFF                        dw 0xFFFF; Limite(15:0)
   132 000000C9 0000                        dw 0x0000; Base(15:0)
   133 000000CB 00                          db 0x00;   Base(23:16)
   134 000000CC 92                          db 0x92;   Acceso (P=1,DPL=0,S=1,Type=0010 R/W) <-- RW=1
   135 000000CD CF                          db 0xCF;   Gran (G=1,D/B=1,L=0,AVL=0), Limite(19:16)
   136 000000CE 00                          db 0x00;   Base(31:24)
   137                                  gdt_data_ro: ; Índice 3, Selector 0x18 - *** READ ONLY (PARA DATOS DS/ES/FS/GS) ***
   138 000000CF FFFF                        dw 0xFFFF; Limite(15:0)
   139 000000D1 0000                        dw 0x0000; Base(15:0)
   140 000000D3 00                          db 0x00;   Base(23:16)
   141 000000D4 90                          db 0x90;   Acceso (P=1,DPL=0,S=1,Type=0000 RO)  <-- RW=0
   142 000000D5 CF                          db 0xCF;   Gran (G=1,D/B=1,L=0,AVL=0), Limite(19:16)
   143 000000D6 00                          db 0x00;   Base(31:24)
   144                                  gdt_end:
   145                                  
   146                                  ; Descriptor de GDT (Puntero para LGDT)
   147                                  gdt_descriptor:
   148 000000D7 1F00                        dw gdt_end - gdt_start - 1 ; Límite (Tamaño - 1)
   149 000000D9 [B7000000]                  dd gdt_start              ; Dirección Base de la GDT
   150                                  
   151                                  ; Constantes para Selectores
   152                                  CODE_SEG      equ gdt_code - gdt_start      ; 0x08
   153                                  DATA_RW_SEG   equ gdt_data_rw - gdt_start   ; 0x10 (Para SS)
   154                                  DATA_RO_SEG   equ gdt_data_ro - gdt_start   ; 0x18 (Para DS, ES, etc.)
   155                                  
   156                                  ; Mensajes
   157 000000DD 426F6F746C6F616465-     msg_starting        db 'Bootloader Starting (SS=RW, DS=RO Test)...', 0x0D, 0x0A, 0
   157 000000E6 72205374617274696E-
   157 000000EF 67202853533D52572C-
   157 000000F8 2044533D524F205465-
   157 00000101 7374292E2E2E0D0A00 
   158 0000010A 4C6F6164696E672047-     msg_gdt_load        db 'Loading GDT...', 0x0D, 0x0A, 0
   158 00000113 44542E2E2E0D0A00   
   159 0000011B 456E746572696E6720-     msg_entering_pm     db 'Entering Protected Mode...', 0x0D, 0x0A, 0
   159 00000124 50726F746563746564-
   159 0000012D 204D6F64652E2E2E0D-
   159 00000136 0A00               
   160 00000138 50726F746563746564-     msg_pm_active       db 'Protected Mode Active.', 0
   160 00000141 204D6F646520416374-
   160 0000014A 6976652E00         
   161 0000014F 537461636B20536574-     msg_seg_stack_set_mix db 'Stack Set (SS=RW), Data Segs Set (DS/ES=RO).', 0
   161 00000158 202853533D5257292C-
   161 00000161 204461746120536567-
   161 0000016A 732053657420284453-
   161 00000173 2F45533D524F292E00 
   162 0000017C 417474656D7074696E-     msg_attempt_write_ds db 'Attempting write to [DS(RO):0x10000]...', 0
   162 00000185 672077726974652074-
   162 0000018E 6F205B445328524F29-
   162 00000197 3A307831303030305D-
   162 000001A0 2E2E2E00           
   163 000001A4 4552524F523A205772-     msg_write_succeeded_error db 'ERROR: Write to RO segment SUCCEEDED!', 0
   163 000001AD 69746520746F20524F-
   163 000001B6 207365676D656E7420-
   163 000001BF 535543434545444544-
   163 000001C8 2100               
   164                                  
   165                                  ; Puntero para LSS (Define SS como R/W)
   166                                  stack_ptr:
   167 000001CA 00000900                    dd 0x90000      ; Nuevo valor para ESP (32 bits)
   168 000001CE 1000                        dw DATA_RW_SEG  ; *** USA EL SELECTOR R/W (0x10) PARA SS ***
   169                                  
   170                                  ; --- Relleno y Firma de Arranque ---
   171                                  %define BOOT_SECTOR_SIZE 512
   172                                  %define BOOT_SIGNATURE_OFFSET (BOOT_SECTOR_SIZE - 2)
   173 000001D0 00<rep 2Eh>                 times BOOT_SIGNATURE_OFFSET - ($ - $$) db 0  ; Rellena hasta offset 510
   174 000001FE 55AA                        dw 0xAA55                                    ; Firma Mágica
